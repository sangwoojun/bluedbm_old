//
// Generated by Bluespec Compiler, version 2014.03.beta2 (build 33633, 2014-03-26)
//
// On Tue Sep  9 02:13:54 EDT 2014
//
//
// Ports:
// Name                         I/O  size props
// pcie_txn                       O     8
// pcie_txp                       O     8
// user_app_rdy                   O     1
// user_lnk_up                    O     1
// cfg_bridge_serr_en             O     1
// cfg_bus_number                 O     8
// cfg_command                    O    16
// cfg_dcommand                   O    16
// cfg_dcommand2                  O    16
// cfg_device_number              O     5
// cfg_function_number            O     3
// cfg_lcommand                   O    16
// cfg_lstatus                    O    16
// cfg_pcie_link_state            O     3
// cfg_received_func_lvl_rst      O     1
// cfg_slot_control_electromech_il_ctl_pulse  O     1
// cfg_status                     O    16
// cfg_to_turnoff                 O     1
// cfg_vc_tcvc_map                O     7
// RDY_tlp_request_put            O     1
// tlp_response_get               O   153
// RDY_tlp_response_get           O     1
// CLK_user_clk_out               O     1 clock
// CLK_GATE_user_clk_out          O     1 const
// CLK_epClock125                 O     1 clock
// CLK_GATE_epClock125            O     1 const
// CLK_epClock250                 O     1 clock
// CLK_GATE_epClock250            O     1 const
// RST_N_user_reset_out           O     1 reset
// RST_N_epReset125               O     1 reset
// RST_N_epReset250               O     1 reset
// CLK                            I     1 clock
// RST_N                          I     1 reset
// pcie_rxn_v                     I     8
// pcie_rxp_v                     I     8
// cfg_interrupt_v                I     1
// cfg_pciecap_interrupt_msgnum_v  I     5
// cfg_trn_pending_v              I     1
// cfg_turnoff_ok_v               I     1
// tlp_request_put                I   153
// EN_tlp_request_put             I     1
// EN_tlp_response_get            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPcieEndpointX7(CLK,
			RST_N,

			pcie_rxn_v,

			pcie_rxp_v,

			pcie_txn,

			pcie_txp,

			user_app_rdy,

			user_lnk_up,

			cfg_bridge_serr_en,

			cfg_bus_number,

			cfg_command,

			cfg_dcommand,

			cfg_dcommand2,

			cfg_device_number,

			cfg_function_number,

			cfg_interrupt_v,

			cfg_lcommand,

			cfg_lstatus,

			cfg_pcie_link_state,

			cfg_pciecap_interrupt_msgnum_v,

			cfg_received_func_lvl_rst,

			cfg_slot_control_electromech_il_ctl_pulse,

			cfg_status,

			cfg_to_turnoff,

			cfg_trn_pending_v,

			cfg_turnoff_ok_v,

			cfg_vc_tcvc_map,

			tlp_request_put,
			EN_tlp_request_put,
			RDY_tlp_request_put,

			EN_tlp_response_get,
			tlp_response_get,
			RDY_tlp_response_get,

			CLK_user_clk_out,
			CLK_GATE_user_clk_out,

			CLK_epClock125,
			CLK_GATE_epClock125,

			CLK_epClock250,
			CLK_GATE_epClock250,

			RST_N_user_reset_out,
			RST_N_epReset125,
			RST_N_epReset250);
  input  CLK;
  input  RST_N;

  // action method pcie_rxn
  input  [7 : 0] pcie_rxn_v;

  // action method pcie_rxp
  input  [7 : 0] pcie_rxp_v;

  // value method pcie_txn
  output [7 : 0] pcie_txn;

  // value method pcie_txp
  output [7 : 0] pcie_txp;

  // value method user_app_rdy
  output user_app_rdy;

  // value method user_lnk_up
  output user_lnk_up;

  // value method cfg_bridge_serr_en
  output cfg_bridge_serr_en;

  // value method cfg_bus_number
  output [7 : 0] cfg_bus_number;

  // value method cfg_command
  output [15 : 0] cfg_command;

  // value method cfg_dcommand
  output [15 : 0] cfg_dcommand;

  // value method cfg_dcommand2
  output [15 : 0] cfg_dcommand2;

  // value method cfg_device_number
  output [4 : 0] cfg_device_number;

  // value method cfg_function_number
  output [2 : 0] cfg_function_number;

  // action method cfg_interrupt
  input  cfg_interrupt_v;

  // value method cfg_lcommand
  output [15 : 0] cfg_lcommand;

  // value method cfg_lstatus
  output [15 : 0] cfg_lstatus;

  // value method cfg_pcie_link_state
  output [2 : 0] cfg_pcie_link_state;

  // action method cfg_pciecap_interrupt_msgnum
  input  [4 : 0] cfg_pciecap_interrupt_msgnum_v;

  // value method cfg_received_func_lvl_rst
  output cfg_received_func_lvl_rst;

  // value method cfg_slot_control_electromech_il_ctl_pulse
  output cfg_slot_control_electromech_il_ctl_pulse;

  // value method cfg_status
  output [15 : 0] cfg_status;

  // value method cfg_to_turnoff
  output cfg_to_turnoff;

  // action method cfg_trn_pending
  input  cfg_trn_pending_v;

  // action method cfg_turnoff_ok
  input  cfg_turnoff_ok_v;

  // value method cfg_vc_tcvc_map
  output [6 : 0] cfg_vc_tcvc_map;

  // action method tlp_request_put
  input  [152 : 0] tlp_request_put;
  input  EN_tlp_request_put;
  output RDY_tlp_request_put;

  // actionvalue method tlp_response_get
  input  EN_tlp_response_get;
  output [152 : 0] tlp_response_get;
  output RDY_tlp_response_get;

  // oscillator and gates for output clock CLK_user_clk_out
  output CLK_user_clk_out;
  output CLK_GATE_user_clk_out;

  // oscillator and gates for output clock CLK_epClock125
  output CLK_epClock125;
  output CLK_GATE_epClock125;

  // oscillator and gates for output clock CLK_epClock250
  output CLK_epClock250;
  output CLK_GATE_epClock250;

  // output resets
  output RST_N_user_reset_out;
  output RST_N_epReset125;
  output RST_N_epReset250;

  // signals for module outputs
  wire [152 : 0] tlp_response_get;
  wire [15 : 0] cfg_command,
		cfg_dcommand,
		cfg_dcommand2,
		cfg_lcommand,
		cfg_lstatus,
		cfg_status;
  wire [7 : 0] cfg_bus_number, pcie_txn, pcie_txp;
  wire [6 : 0] cfg_vc_tcvc_map;
  wire [4 : 0] cfg_device_number;
  wire [2 : 0] cfg_function_number, cfg_pcie_link_state;
  wire CLK_GATE_epClock125,
       CLK_GATE_epClock250,
       CLK_GATE_user_clk_out,
       CLK_epClock125,
       CLK_epClock250,
       CLK_user_clk_out,
       RDY_tlp_request_put,
       RDY_tlp_response_get,
       RST_N_epReset125,
       RST_N_epReset250,
       RST_N_user_reset_out,
       cfg_bridge_serr_en,
       cfg_received_func_lvl_rst,
       cfg_slot_control_electromech_il_ctl_pulse,
       cfg_to_turnoff,
       user_app_rdy,
       user_lnk_up;

  // inlined wires
  wire [94 : 0] fAxiRx_rw_enq_wget;
  wire [72 : 0] fAxiTx_rw_enq_wget;
  wire fAxiRx_rw_enq_whas, fAxiTx_rw_enq_whas;

  // register fAxiRx_taggedReg
  reg [95 : 0] fAxiRx_taggedReg;
  wire [95 : 0] fAxiRx_taggedReg_D_IN;
  wire fAxiRx_taggedReg_EN;

  // register fAxiTx_taggedReg
  reg [73 : 0] fAxiTx_taggedReg;
  wire [73 : 0] fAxiTx_taggedReg_D_IN;
  wire fAxiTx_taggedReg_EN;

  // register pclk_sel
  reg pclk_sel;
  wire pclk_sel_D_IN, pclk_sel_EN;

  // register pclk_sel_reg1
  reg [7 : 0] pclk_sel_reg1;
  wire [7 : 0] pclk_sel_reg1_D_IN;
  wire pclk_sel_reg1_EN;

  // register pclk_sel_reg2
  reg [7 : 0] pclk_sel_reg2;
  wire [7 : 0] pclk_sel_reg2_D_IN;
  wire pclk_sel_reg2_EN;

  // ports of submodule b2c
  wire b2c_IN, b2c_OUT;

  // ports of submodule bbufc
  wire bbufc_CE0,
       bbufc_CE1,
       bbufc_IGNORE0,
       bbufc_IGNORE1,
       bbufc_O,
       bbufc_S0,
       bbufc_S1;

  // ports of submodule c2b
  wire c2b_OUT;

  // ports of submodule c2b_fb
  wire c2b_fb_OUT;

  // ports of submodule clkgen_clkout0buffer
  wire clkgen_clkout0buffer_O;

  // ports of submodule clkgen_pll
  wire clkgen_pll_CLKFBIN,
       clkgen_pll_CLKFBOUT,
       clkgen_pll_CLKOUT0,
       clkgen_pll_CLKOUT0B,
       clkgen_pll_CLKOUT1,
       clkgen_pll_CLKOUT1B,
       clkgen_pll_CLKOUT2,
       clkgen_pll_CLKOUT2B,
       clkgen_pll_CLKOUT3,
       clkgen_pll_CLKOUT3B,
       clkgen_pll_CLKOUT4,
       clkgen_pll_CLKOUT5,
       clkgen_pll_CLKOUT6;

  // ports of submodule clkgen_pll_clkfbbuf
  wire clkgen_pll_clkfbbuf_O;

  // ports of submodule clkgen_pll_reset
  wire clkgen_pll_reset_RESET_OUT;

  // ports of submodule clkgen_rst_n
  wire clkgen_rst_n_OUT_RST;

  // ports of submodule clockGen_clkout0buffer
  wire clockGen_clkout0buffer_O;

  // ports of submodule clockGen_clkout1buffer
  wire clockGen_clkout1buffer_O;

  // ports of submodule clockGen_clkout2buffer
  wire clockGen_clkout2buffer_O;

  // ports of submodule clockGen_pll
  wire clockGen_pll_CLKFBIN,
       clockGen_pll_CLKFBOUT,
       clockGen_pll_CLKOUT0,
       clockGen_pll_CLKOUT0B,
       clockGen_pll_CLKOUT1,
       clockGen_pll_CLKOUT1B,
       clockGen_pll_CLKOUT2,
       clockGen_pll_CLKOUT2B,
       clockGen_pll_CLKOUT3,
       clockGen_pll_CLKOUT3B,
       clockGen_pll_CLKOUT4,
       clockGen_pll_CLKOUT5,
       clockGen_pll_CLKOUT6,
       clockGen_pll_LOCKED;

  // ports of submodule clockGen_pll_reset
  wire clockGen_pll_reset_RESET_OUT;

  // ports of submodule gb
  wire [152 : 0] gb_pci_request_put, gb_pci_response_get;
  wire [80 : 0] gb_tlp_request_get, gb_tlp_response_put;
  wire gb_EN_pci_request_put,
       gb_EN_pci_response_get,
       gb_EN_tlp_request_get,
       gb_EN_tlp_response_put,
       gb_RDY_pci_request_put,
       gb_RDY_pci_response_get,
       gb_RDY_tlp_request_get,
       gb_RDY_tlp_response_put;

  // ports of submodule pcie_ep
  wire [63 : 0] pcie_ep_cfg_dsn,
		pcie_ep_m_axis_rx_tdata,
		pcie_ep_s_axis_tx_tdata;
  wire [21 : 0] pcie_ep_m_axis_rx_tuser;
  wire [15 : 0] pcie_ep_cfg_command,
		pcie_ep_cfg_dcommand,
		pcie_ep_cfg_dcommand2,
		pcie_ep_cfg_lcommand,
		pcie_ep_cfg_lstatus,
		pcie_ep_cfg_status;
  wire [7 : 0] pcie_ep_cfg_bus_number,
	       pcie_ep_m_axis_rx_tkeep,
	       pcie_ep_pci_exp_rxn,
	       pcie_ep_pci_exp_rxp,
	       pcie_ep_pci_exp_txn,
	       pcie_ep_pci_exp_txp,
	       pcie_ep_pipe_pclk_sel_out,
	       pcie_ep_s_axis_tx_tkeep;
  wire [6 : 0] pcie_ep_cfg_vc_tcvc_map;
  wire [4 : 0] pcie_ep_cfg_device_number,
	       pcie_ep_cfg_pciecap_interrupt_msgnum;
  wire [3 : 0] pcie_ep_s_axis_tx_tuser;
  wire [2 : 0] pcie_ep_cfg_function_number,
	       pcie_ep_cfg_pcie_link_state,
	       pcie_ep_fc_sel;
  wire pcie_ep_cfg_bridge_serr_en,
       pcie_ep_cfg_interrupt,
       pcie_ep_cfg_received_func_lvl_rst,
       pcie_ep_cfg_slot_control_electromech_il_ctl_pulse,
       pcie_ep_cfg_to_turnoff,
       pcie_ep_cfg_trn_pending,
       pcie_ep_cfg_turnoff_ok,
       pcie_ep_m_axis_rx_tlast,
       pcie_ep_m_axis_rx_tready,
       pcie_ep_m_axis_rx_tvalid,
       pcie_ep_pipe_mmcm_lock_in,
       pcie_ep_pipe_txoutclk_out,
       pcie_ep_rx_np_ok,
       pcie_ep_rx_np_req,
       pcie_ep_s_axis_tx_tlast,
       pcie_ep_s_axis_tx_tready,
       pcie_ep_s_axis_tx_tvalid,
       pcie_ep_tx_cfg_gnt,
       pcie_ep_user_app_rdy,
       pcie_ep_user_clk_out,
       pcie_ep_user_lnk_up,
       pcie_ep_user_reset_out;

  // ports of submodule reset125
  wire reset125_OUT_RST;

  // ports of submodule reset250
  wire reset250_OUT_RST;

  // ports of submodule rsto
  wire rsto_OUT_RST;

  // ports of submodule txoutclk_buf
  wire txoutclk_buf_O;

  // ports of submodule user_reset_n
  wire user_reset_n_RESET_OUT;

  // rule scheduling signals
  wire WILL_FIRE_RL_drive_axi_tx2,
       WILL_FIRE_RL_fAxiRx_rule_deq,
       WILL_FIRE_RL_fAxiTx_rule_deq;

  // inputs to muxes for submodule ports
  wire [95 : 0] MUX_fAxiRx_taggedReg_write_1__VAL_2;
  wire [73 : 0] MUX_fAxiTx_taggedReg_write_1__VAL_2;
  wire [63 : 0] MUX_pcie_ep_s_axis_tx_tdata_1__VAL_1;
  wire [7 : 0] MUX_pcie_ep_s_axis_tx_tkeep_1__VAL_1;
  wire MUX_pcie_ep_s_axis_tx_tlast_1__VAL_1;

  // remaining internal signals
  wire [63 : 0] IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d97,
		v_data__h7565,
		y_avValue_data__h8645;
  wire [21 : 0] IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d80;
  wire [7 : 0] IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d90,
	       v_keep__h7564,
	       y_avValue_be__h8644;
  wire x1__h4489;

  // oscillator and gates for output clock CLK_user_clk_out
  assign CLK_user_clk_out = pcie_ep_user_clk_out ;
  assign CLK_GATE_user_clk_out = 1'b1 ;

  // oscillator and gates for output clock CLK_epClock125
  assign CLK_epClock125 = clkgen_clkout0buffer_O ;
  assign CLK_GATE_epClock125 = 1'b1 ;

  // oscillator and gates for output clock CLK_epClock250
  assign CLK_epClock250 = pcie_ep_user_clk_out ;
  assign CLK_GATE_epClock250 = 1'b1 ;

  // output resets
  assign RST_N_user_reset_out = pcie_ep_user_reset_out ;
  assign RST_N_epReset125 = reset125_OUT_RST ;
  assign RST_N_epReset250 = reset250_OUT_RST ;

  // value method pcie_txn
  assign pcie_txn = pcie_ep_pci_exp_txn ;

  // value method pcie_txp
  assign pcie_txp = pcie_ep_pci_exp_txp ;

  // value method user_app_rdy
  assign user_app_rdy = pcie_ep_user_app_rdy ;

  // value method user_lnk_up
  assign user_lnk_up = pcie_ep_user_lnk_up ;

  // value method cfg_bridge_serr_en
  assign cfg_bridge_serr_en = pcie_ep_cfg_bridge_serr_en ;

  // value method cfg_bus_number
  assign cfg_bus_number = pcie_ep_cfg_bus_number ;

  // value method cfg_command
  assign cfg_command = pcie_ep_cfg_command ;

  // value method cfg_dcommand
  assign cfg_dcommand = pcie_ep_cfg_dcommand ;

  // value method cfg_dcommand2
  assign cfg_dcommand2 = pcie_ep_cfg_dcommand2 ;

  // value method cfg_device_number
  assign cfg_device_number = pcie_ep_cfg_device_number ;

  // value method cfg_function_number
  assign cfg_function_number = pcie_ep_cfg_function_number ;

  // value method cfg_lcommand
  assign cfg_lcommand = pcie_ep_cfg_lcommand ;

  // value method cfg_lstatus
  assign cfg_lstatus = pcie_ep_cfg_lstatus ;

  // value method cfg_pcie_link_state
  assign cfg_pcie_link_state = pcie_ep_cfg_pcie_link_state ;

  // value method cfg_received_func_lvl_rst
  assign cfg_received_func_lvl_rst = pcie_ep_cfg_received_func_lvl_rst ;

  // value method cfg_slot_control_electromech_il_ctl_pulse
  assign cfg_slot_control_electromech_il_ctl_pulse =
	     pcie_ep_cfg_slot_control_electromech_il_ctl_pulse ;

  // value method cfg_status
  assign cfg_status = pcie_ep_cfg_status ;

  // value method cfg_to_turnoff
  assign cfg_to_turnoff = pcie_ep_cfg_to_turnoff ;

  // value method cfg_vc_tcvc_map
  assign cfg_vc_tcvc_map = pcie_ep_cfg_vc_tcvc_map ;

  // action method tlp_request_put
  assign RDY_tlp_request_put = gb_RDY_pci_request_put ;

  // actionvalue method tlp_response_get
  assign tlp_response_get = gb_pci_response_get ;
  assign RDY_tlp_response_get = gb_RDY_pci_response_get ;

  // submodule b2c
  CONNECTNET b2c(.IN(b2c_IN), .OUT(b2c_OUT));

  // submodule bbufc
  BUFGCTRL bbufc(.I0(clockGen_clkout0buffer_O),
		 .I1(clockGen_clkout1buffer_O),
		 .CE0(bbufc_CE0),
		 .CE1(bbufc_CE1),
		 .IGNORE0(bbufc_IGNORE0),
		 .IGNORE1(bbufc_IGNORE1),
		 .S0(bbufc_S0),
		 .S1(bbufc_S1),
		 .O(bbufc_O));

  // submodule c2b
  CONNECTNET c2b(.IN(txoutclk_buf_O), .OUT(c2b_OUT));

  // submodule c2b_fb
  CONNECTNET c2b_fb(.IN(clockGen_pll_CLKFBOUT), .OUT(c2b_fb_OUT));

  // submodule clkgen_clkout0buffer
  BUFG clkgen_clkout0buffer(.I(clkgen_pll_CLKOUT0),
			    .O(clkgen_clkout0buffer_O));

  // submodule clkgen_clkout0nbuffer
  BUFG clkgen_clkout0nbuffer(.I(clkgen_pll_CLKOUT0B), .O());

  // submodule clkgen_clkout1buffer
  BUFG clkgen_clkout1buffer(.I(clkgen_pll_CLKOUT1), .O());

  // submodule clkgen_clkout1nbuffer
  BUFG clkgen_clkout1nbuffer(.I(clkgen_pll_CLKOUT1B), .O());

  // submodule clkgen_clkout2buffer
  BUFG clkgen_clkout2buffer(.I(clkgen_pll_CLKOUT2), .O());

  // submodule clkgen_clkout2nbuffer
  BUFG clkgen_clkout2nbuffer(.I(clkgen_pll_CLKOUT2B), .O());

  // submodule clkgen_clkout3buffer
  BUFG clkgen_clkout3buffer(.I(clkgen_pll_CLKOUT3), .O());

  // submodule clkgen_clkout3nbuffer
  BUFG clkgen_clkout3nbuffer(.I(clkgen_pll_CLKOUT3B), .O());

  // submodule clkgen_clkout4buffer
  BUFG clkgen_clkout4buffer(.I(clkgen_pll_CLKOUT4), .O());

  // submodule clkgen_clkout5buffer
  BUFG clkgen_clkout5buffer(.I(clkgen_pll_CLKOUT5), .O());

  // submodule clkgen_clkout6buffer
  BUFG clkgen_clkout6buffer(.I(clkgen_pll_CLKOUT6), .O());

  // submodule clkgen_pll
  MMCME2_ADV #(.BANDWIDTH("OPTIMIZED"),
	       .CLKFBOUT_USE_FINE_PS("FALSE"),
	       .CLKOUT0_USE_FINE_PS("FALSE"),
	       .CLKOUT1_USE_FINE_PS("FALSE"),
	       .CLKOUT2_USE_FINE_PS("FALSE"),
	       .CLKOUT3_USE_FINE_PS("FALSE"),
	       .CLKOUT4_CASCADE("FALSE"),
	       .CLKOUT4_USE_FINE_PS("FALSE"),
	       .CLKOUT5_USE_FINE_PS("FALSE"),
	       .CLKOUT6_USE_FINE_PS("FALSE"),
	       .COMPENSATION("ZHOLD"),
	       .STARTUP_WAIT("FALSE"),
	       .CLKFBOUT_MULT_F(4.0),
	       .CLKFBOUT_PHASE(0.0),
	       .CLKIN1_PERIOD(4.0),
	       .CLKIN2_PERIOD(0.0),
	       .DIVCLK_DIVIDE(32'd1),
	       .CLKOUT0_DIVIDE_F(8.0),
	       .CLKOUT0_DUTY_CYCLE(0.5),
	       .CLKOUT0_PHASE(0.0),
	       .CLKOUT1_DIVIDE(32'd10),
	       .CLKOUT1_DUTY_CYCLE(0.5),
	       .CLKOUT1_PHASE(0.0),
	       .CLKOUT2_DIVIDE(32'd10),
	       .CLKOUT2_DUTY_CYCLE(0.5),
	       .CLKOUT2_PHASE(0.0),
	       .CLKOUT3_DIVIDE(32'd10),
	       .CLKOUT3_DUTY_CYCLE(0.5),
	       .CLKOUT3_PHASE(0.0),
	       .CLKOUT4_DIVIDE(32'd10),
	       .CLKOUT4_DUTY_CYCLE(0.5),
	       .CLKOUT4_PHASE(0.0),
	       .CLKOUT5_DIVIDE(32'd10),
	       .CLKOUT5_DUTY_CYCLE(0.5),
	       .CLKOUT5_PHASE(0.0),
	       .CLKOUT6_DIVIDE(32'd10),
	       .CLKOUT6_DUTY_CYCLE(0.5),
	       .CLKOUT6_PHASE(0.0),
	       .REF_JITTER1(1.0e-2),
	       .REF_JITTER2(1.0e-2)) clkgen_pll(.CLKIN1(pcie_ep_user_clk_out),
						.RST(clkgen_pll_reset_RESET_OUT),
						.CLKIN2(1'd0),
						.CLKINSEL(1'd1),
						.DADDR(7'd0),
						.DCLK(1'd0),
						.DEN(1'd0),
						.DI(16'd0),
						.DWE(1'd0),
						.PSCLK(1'd0),
						.PSEN(1'd0),
						.PSINCDEC(1'd0),
						.PWRDWN(1'd0),
						.CLKFBIN(clkgen_pll_CLKFBIN),
						.LOCKED(),
						.CLKFBOUT(clkgen_pll_CLKFBOUT),
						.CLKFBOUTB(),
						.CLKOUT0(clkgen_pll_CLKOUT0),
						.CLKOUT0B(clkgen_pll_CLKOUT0B),
						.CLKOUT1(clkgen_pll_CLKOUT1),
						.CLKOUT1B(clkgen_pll_CLKOUT1B),
						.CLKOUT2(clkgen_pll_CLKOUT2),
						.CLKOUT2B(clkgen_pll_CLKOUT2B),
						.CLKOUT3(clkgen_pll_CLKOUT3),
						.CLKOUT3B(clkgen_pll_CLKOUT3B),
						.CLKOUT4(clkgen_pll_CLKOUT4),
						.CLKOUT5(clkgen_pll_CLKOUT5),
						.CLKOUT6(clkgen_pll_CLKOUT6));

  // submodule clkgen_pll_clkfbbuf
  BUFG clkgen_pll_clkfbbuf(.I(clkgen_pll_CLKFBOUT),
			   .O(clkgen_pll_clkfbbuf_O));

  // submodule clkgen_pll_reset
  ResetInverter clkgen_pll_reset(.RESET_IN(user_reset_n_RESET_OUT),
				 .RESET_OUT(clkgen_pll_reset_RESET_OUT));

  // submodule clkgen_rst
  ResetInverter clkgen_rst(.RESET_IN(clkgen_rst_n_OUT_RST), .RESET_OUT());

  // submodule clkgen_rst_n
  SyncResetA #(.RSTDELAY(32'd2)) clkgen_rst_n(.CLK(pcie_ep_user_clk_out),
					      .IN_RST(user_reset_n_RESET_OUT),
					      .OUT_RST(clkgen_rst_n_OUT_RST));

  // submodule clockGen_clkout0buffer
  BUFG clockGen_clkout0buffer(.I(clockGen_pll_CLKOUT0),
			      .O(clockGen_clkout0buffer_O));

  // submodule clockGen_clkout0nbuffer
  BUFG clockGen_clkout0nbuffer(.I(clockGen_pll_CLKOUT0B), .O());

  // submodule clockGen_clkout1buffer
  BUFG clockGen_clkout1buffer(.I(clockGen_pll_CLKOUT1),
			      .O(clockGen_clkout1buffer_O));

  // submodule clockGen_clkout1nbuffer
  BUFG clockGen_clkout1nbuffer(.I(clockGen_pll_CLKOUT1B), .O());

  // submodule clockGen_clkout2buffer
  BUFG clockGen_clkout2buffer(.I(clockGen_pll_CLKOUT2),
			      .O(clockGen_clkout2buffer_O));

  // submodule clockGen_clkout2nbuffer
  BUFG clockGen_clkout2nbuffer(.I(clockGen_pll_CLKOUT2B), .O());

  // submodule clockGen_clkout3buffer
  BUFG clockGen_clkout3buffer(.I(clockGen_pll_CLKOUT3), .O());

  // submodule clockGen_clkout3nbuffer
  BUFG clockGen_clkout3nbuffer(.I(clockGen_pll_CLKOUT3B), .O());

  // submodule clockGen_clkout4buffer
  BUFG clockGen_clkout4buffer(.I(clockGen_pll_CLKOUT4), .O());

  // submodule clockGen_clkout5buffer
  BUFG clockGen_clkout5buffer(.I(clockGen_pll_CLKOUT5), .O());

  // submodule clockGen_clkout6buffer
  BUFG clockGen_clkout6buffer(.I(clockGen_pll_CLKOUT6), .O());

  // submodule clockGen_pll
  MMCME2_ADV #(.BANDWIDTH("OPTIMIZED"),
	       .CLKFBOUT_USE_FINE_PS("FALSE"),
	       .CLKOUT0_USE_FINE_PS("FALSE"),
	       .CLKOUT1_USE_FINE_PS("FALSE"),
	       .CLKOUT2_USE_FINE_PS("FALSE"),
	       .CLKOUT3_USE_FINE_PS("FALSE"),
	       .CLKOUT4_CASCADE("FALSE"),
	       .CLKOUT4_USE_FINE_PS("FALSE"),
	       .CLKOUT5_USE_FINE_PS("FALSE"),
	       .CLKOUT6_USE_FINE_PS("FALSE"),
	       .COMPENSATION("INTERNAL"),
	       .STARTUP_WAIT("FALSE"),
	       .CLKFBOUT_MULT_F(10.0),
	       .CLKFBOUT_PHASE(0.0),
	       .CLKIN1_PERIOD(10.0),
	       .CLKIN2_PERIOD(0.0),
	       .DIVCLK_DIVIDE(32'd1),
	       .CLKOUT0_DIVIDE_F(8.0),
	       .CLKOUT0_DUTY_CYCLE(0.5),
	       .CLKOUT0_PHASE(0.0),
	       .CLKOUT1_DIVIDE(32'd4),
	       .CLKOUT1_DUTY_CYCLE(0.5),
	       .CLKOUT1_PHASE(0.0),
	       .CLKOUT2_DIVIDE(32'd4),
	       .CLKOUT2_DUTY_CYCLE(0.5),
	       .CLKOUT2_PHASE(0.0),
	       .CLKOUT3_DIVIDE(32'd1),
	       .CLKOUT3_DUTY_CYCLE(0.5),
	       .CLKOUT3_PHASE(0.0),
	       .CLKOUT4_DIVIDE(32'd1),
	       .CLKOUT4_DUTY_CYCLE(0.5),
	       .CLKOUT4_PHASE(0.0),
	       .CLKOUT5_DIVIDE(32'd1),
	       .CLKOUT5_DUTY_CYCLE(0.5),
	       .CLKOUT5_PHASE(0.0),
	       .CLKOUT6_DIVIDE(32'd1),
	       .CLKOUT6_DUTY_CYCLE(0.5),
	       .CLKOUT6_PHASE(0.0),
	       .REF_JITTER1(1.0e-2),
	       .REF_JITTER2(1.0e-2)) clockGen_pll(.CLKIN1(b2c_OUT),
						  .RST(clockGen_pll_reset_RESET_OUT),
						  .CLKIN2(1'd0),
						  .CLKINSEL(1'd1),
						  .DADDR(7'd0),
						  .DCLK(1'd0),
						  .DEN(1'd0),
						  .DI(16'd0),
						  .DWE(1'd0),
						  .PSCLK(1'd0),
						  .PSEN(1'd0),
						  .PSINCDEC(1'd0),
						  .PWRDWN(1'd0),
						  .CLKFBIN(clockGen_pll_CLKFBIN),
						  .LOCKED(clockGen_pll_LOCKED),
						  .CLKFBOUT(clockGen_pll_CLKFBOUT),
						  .CLKFBOUTB(),
						  .CLKOUT0(clockGen_pll_CLKOUT0),
						  .CLKOUT0B(clockGen_pll_CLKOUT0B),
						  .CLKOUT1(clockGen_pll_CLKOUT1),
						  .CLKOUT1B(clockGen_pll_CLKOUT1B),
						  .CLKOUT2(clockGen_pll_CLKOUT2),
						  .CLKOUT2B(clockGen_pll_CLKOUT2B),
						  .CLKOUT3(clockGen_pll_CLKOUT3),
						  .CLKOUT3B(clockGen_pll_CLKOUT3B),
						  .CLKOUT4(clockGen_pll_CLKOUT4),
						  .CLKOUT5(clockGen_pll_CLKOUT5),
						  .CLKOUT6(clockGen_pll_CLKOUT6));

  // submodule clockGen_pll_reset
  ResetInverter clockGen_pll_reset(.RESET_IN(RST_N),
				   .RESET_OUT(clockGen_pll_reset_RESET_OUT));

  // submodule gb
  mkPcieGearbox gb(.CLK_epClock250(pcie_ep_user_clk_out),
		   .RST_N_epReset250(reset250_OUT_RST),
		   .CLK_epClock125(clkgen_clkout0buffer_O),
		   .RST_N_epReset125(reset125_OUT_RST),
		   .pci_request_put(gb_pci_request_put),
		   .tlp_response_put(gb_tlp_response_put),
		   .EN_tlp_request_get(gb_EN_tlp_request_get),
		   .EN_tlp_response_put(gb_EN_tlp_response_put),
		   .EN_pci_request_put(gb_EN_pci_request_put),
		   .EN_pci_response_get(gb_EN_pci_response_get),
		   .tlp_request_get(gb_tlp_request_get),
		   .RDY_tlp_request_get(gb_RDY_tlp_request_get),
		   .RDY_tlp_response_put(gb_RDY_tlp_response_put),
		   .RDY_pci_request_put(gb_RDY_pci_request_put),
		   .pci_response_get(gb_pci_response_get),
		   .RDY_pci_response_get(gb_RDY_pci_response_get));

  // submodule pcie_ep
  pcie_7x_0 pcie_ep(.sys_clk(CLK),
		    .sys_rst_n(RST_N),
		    .pipe_dclk_in(clockGen_clkout0buffer_O),
		    .pipe_oobclk_in(clockGen_clkout0buffer_O),
		    .pipe_userclk1_in(clockGen_clkout2buffer_O),
		    .pipe_userclk2_in(clockGen_clkout2buffer_O),
		    .pipe_pclk_in(bbufc_O),
		    .pipe_rxusrclk_in(bbufc_O),
		    .cfg_dsn(pcie_ep_cfg_dsn),
		    .cfg_interrupt(pcie_ep_cfg_interrupt),
		    .cfg_pciecap_interrupt_msgnum(pcie_ep_cfg_pciecap_interrupt_msgnum),
		    .cfg_trn_pending(pcie_ep_cfg_trn_pending),
		    .cfg_turnoff_ok(pcie_ep_cfg_turnoff_ok),
		    .fc_sel(pcie_ep_fc_sel),
		    .m_axis_rx_tready(pcie_ep_m_axis_rx_tready),
		    .pci_exp_rxn(pcie_ep_pci_exp_rxn),
		    .pci_exp_rxp(pcie_ep_pci_exp_rxp),
		    .pipe_mmcm_lock_in(pcie_ep_pipe_mmcm_lock_in),
		    .rx_np_ok(pcie_ep_rx_np_ok),
		    .rx_np_req(pcie_ep_rx_np_req),
		    .s_axis_tx_tdata(pcie_ep_s_axis_tx_tdata),
		    .s_axis_tx_tkeep(pcie_ep_s_axis_tx_tkeep),
		    .s_axis_tx_tlast(pcie_ep_s_axis_tx_tlast),
		    .s_axis_tx_tuser(pcie_ep_s_axis_tx_tuser),
		    .s_axis_tx_tvalid(pcie_ep_s_axis_tx_tvalid),
		    .tx_cfg_gnt(pcie_ep_tx_cfg_gnt),
		    .pci_exp_txp(pcie_ep_pci_exp_txp),
		    .pci_exp_txn(pcie_ep_pci_exp_txn),
		    .user_lnk_up(pcie_ep_user_lnk_up),
		    .user_app_rdy(pcie_ep_user_app_rdy),
		    .fc_ph(),
		    .fc_pd(),
		    .fc_nph(),
		    .fc_npd(),
		    .fc_cplh(),
		    .fc_cpld(),
		    .tx_buf_av(),
		    .tx_err_drop(),
		    .tx_cfg_req(),
		    .s_axis_tx_tready(pcie_ep_s_axis_tx_tready),
		    .m_axis_rx_tlast(pcie_ep_m_axis_rx_tlast),
		    .m_axis_rx_tdata(pcie_ep_m_axis_rx_tdata),
		    .m_axis_rx_tkeep(pcie_ep_m_axis_rx_tkeep),
		    .m_axis_rx_tuser(pcie_ep_m_axis_rx_tuser),
		    .m_axis_rx_tvalid(pcie_ep_m_axis_rx_tvalid),
		    .cfg_bus_number(pcie_ep_cfg_bus_number),
		    .cfg_device_number(pcie_ep_cfg_device_number),
		    .cfg_function_number(pcie_ep_cfg_function_number),
		    .cfg_lcommand(pcie_ep_cfg_lcommand),
		    .cfg_bridge_serr_en(pcie_ep_cfg_bridge_serr_en),
		    .cfg_command(pcie_ep_cfg_command),
		    .cfg_dcommand(pcie_ep_cfg_dcommand),
		    .cfg_dcommand2(pcie_ep_cfg_dcommand2),
		    .cfg_lstatus(pcie_ep_cfg_lstatus),
		    .cfg_pcie_link_state(pcie_ep_cfg_pcie_link_state),
		    .cfg_received_func_lvl_rst(pcie_ep_cfg_received_func_lvl_rst),
		    .cfg_slot_control_electromech_il_ctl_pulse(pcie_ep_cfg_slot_control_electromech_il_ctl_pulse),
		    .cfg_status(pcie_ep_cfg_status),
		    .cfg_to_turnoff(pcie_ep_cfg_to_turnoff),
		    .cfg_vc_tcvc_map(pcie_ep_cfg_vc_tcvc_map),
		    .pipe_pclk_sel_out(pcie_ep_pipe_pclk_sel_out),
		    .user_clk_out(pcie_ep_user_clk_out),
		    .pipe_txoutclk_out(pcie_ep_pipe_txoutclk_out),
		    .user_reset_out(pcie_ep_user_reset_out));

  // submodule reset125
  SyncResetA #(.RSTDELAY(32'd3)) reset125(.CLK(clkgen_clkout0buffer_O),
					  .IN_RST(user_reset_n_RESET_OUT),
					  .OUT_RST(reset125_OUT_RST));

  // submodule reset250
  SyncResetA #(.RSTDELAY(32'd3)) reset250(.CLK(pcie_ep_user_clk_out),
					  .IN_RST(user_reset_n_RESET_OUT),
					  .OUT_RST(reset250_OUT_RST));

  // submodule rsto
  SyncResetA #(.RSTDELAY(32'd1)) rsto(.CLK(bbufc_O),
				      .IN_RST(RST_N),
				      .OUT_RST(rsto_OUT_RST));

  // submodule txoutclk_buf
  BUFG txoutclk_buf(.I(pcie_ep_pipe_txoutclk_out), .O(txoutclk_buf_O));

  // submodule user_reset_n
  ResetInverter user_reset_n(.RESET_IN(pcie_ep_user_reset_out),
			     .RESET_OUT(user_reset_n_RESET_OUT));

  // rule RL_drive_axi_tx2
  assign WILL_FIRE_RL_drive_axi_tx2 =
	     !pcie_ep_s_axis_tx_tready ||
	     !fAxiTx_taggedReg[73] && !fAxiTx_rw_enq_whas ;

  // rule RL_fAxiTx_rule_deq
  assign WILL_FIRE_RL_fAxiTx_rule_deq =
	     (fAxiTx_taggedReg[73] || fAxiTx_rw_enq_whas) &&
	     pcie_ep_s_axis_tx_tready ;

  // rule RL_fAxiRx_rule_deq
  assign WILL_FIRE_RL_fAxiRx_rule_deq =
	     gb_RDY_tlp_response_put &&
	     (fAxiRx_taggedReg[95] || fAxiRx_rw_enq_whas) ;

  // inputs to muxes for submodule ports
  assign MUX_fAxiRx_taggedReg_write_1__VAL_2 = { 1'd1, fAxiRx_rw_enq_wget } ;
  assign MUX_fAxiTx_taggedReg_write_1__VAL_2 = { 1'd1, fAxiTx_rw_enq_wget } ;
  assign MUX_pcie_ep_s_axis_tx_tdata_1__VAL_1 =
	     fAxiTx_rw_enq_whas ?
	       fAxiTx_rw_enq_wget[63:0] :
	       fAxiTx_taggedReg[63:0] ;
  assign MUX_pcie_ep_s_axis_tx_tkeep_1__VAL_1 =
	     fAxiTx_rw_enq_whas ?
	       fAxiTx_rw_enq_wget[71:64] :
	       fAxiTx_taggedReg[71:64] ;
  assign MUX_pcie_ep_s_axis_tx_tlast_1__VAL_1 =
	     fAxiTx_rw_enq_whas ?
	       fAxiTx_rw_enq_wget[72] :
	       fAxiTx_taggedReg[72] ;

  // inlined wires
  assign fAxiTx_rw_enq_wget =
	     { gb_tlp_request_get[79], v_keep__h7564, v_data__h7565 } ;
  assign fAxiTx_rw_enq_whas =
	     gb_RDY_tlp_request_get && !fAxiTx_taggedReg[73] ;
  assign fAxiRx_rw_enq_wget =
	     { pcie_ep_m_axis_rx_tuser,
	       pcie_ep_m_axis_rx_tlast,
	       pcie_ep_m_axis_rx_tkeep,
	       pcie_ep_m_axis_rx_tdata } ;
  assign fAxiRx_rw_enq_whas = x1__h4489 && pcie_ep_m_axis_rx_tvalid ;

  // register fAxiRx_taggedReg
  assign fAxiRx_taggedReg_D_IN =
	     WILL_FIRE_RL_fAxiRx_rule_deq ?
	       96'h2AAAAAAAAAAAAAAAAAAAAAAA :
	       MUX_fAxiRx_taggedReg_write_1__VAL_2 ;
  assign fAxiRx_taggedReg_EN =
	     WILL_FIRE_RL_fAxiRx_rule_deq ||
	     fAxiRx_rw_enq_whas && !WILL_FIRE_RL_fAxiRx_rule_deq ;

  // register fAxiTx_taggedReg
  assign fAxiTx_taggedReg_D_IN =
	     WILL_FIRE_RL_fAxiTx_rule_deq ?
	       74'h0AAAAAAAAAAAAAAAAAA :
	       MUX_fAxiTx_taggedReg_write_1__VAL_2 ;
  assign fAxiTx_taggedReg_EN =
	     WILL_FIRE_RL_fAxiTx_rule_deq ||
	     fAxiTx_rw_enq_whas && !WILL_FIRE_RL_fAxiTx_rule_deq ;

  // register pclk_sel
  assign pclk_sel_D_IN =
	     ~pclk_sel_reg2 == 8'd0 || pclk_sel_reg2 != 8'd0 && pclk_sel ;
  assign pclk_sel_EN = 1'd1 ;

  // register pclk_sel_reg1
  assign pclk_sel_reg1_D_IN = pcie_ep_pipe_pclk_sel_out ;
  assign pclk_sel_reg1_EN = 1'd1 ;

  // register pclk_sel_reg2
  assign pclk_sel_reg2_D_IN = pclk_sel_reg1 ;
  assign pclk_sel_reg2_EN = 1'd1 ;

  // submodule b2c
  assign b2c_IN = c2b_OUT ;

  // submodule bbufc
  assign bbufc_CE0 = 1'd1 ;
  assign bbufc_CE1 = 1'd1 ;
  assign bbufc_IGNORE0 = 1'd0 ;
  assign bbufc_IGNORE1 = 1'd0 ;
  assign bbufc_S0 = ~pclk_sel ;
  assign bbufc_S1 = pclk_sel ;

  // submodule clkgen_pll
  assign clkgen_pll_CLKFBIN = clkgen_pll_clkfbbuf_O ;

  // submodule clockGen_pll
  assign clockGen_pll_CLKFBIN = c2b_fb_OUT ;

  // submodule gb
  assign gb_pci_request_put = tlp_request_put ;
  assign gb_tlp_response_put =
	     { IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d80[14],
	       fAxiRx_rw_enq_whas ?
		 fAxiRx_rw_enq_wget[72] :
		 fAxiRx_taggedReg[72],
	       IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d80[8:2],
	       y_avValue_be__h8644,
	       y_avValue_data__h8645 } ;
  assign gb_EN_tlp_request_get =
	     gb_RDY_tlp_request_get && !fAxiTx_taggedReg[73] ;
  assign gb_EN_tlp_response_put = WILL_FIRE_RL_fAxiRx_rule_deq ;
  assign gb_EN_pci_request_put = EN_tlp_request_put ;
  assign gb_EN_pci_response_get = EN_tlp_response_get ;

  // submodule pcie_ep
  assign pcie_ep_cfg_dsn = 64'h0000000101000A35 ;
  assign pcie_ep_cfg_interrupt = cfg_interrupt_v ;
  assign pcie_ep_cfg_pciecap_interrupt_msgnum =
	     cfg_pciecap_interrupt_msgnum_v ;
  assign pcie_ep_cfg_trn_pending = cfg_trn_pending_v ;
  assign pcie_ep_cfg_turnoff_ok = cfg_turnoff_ok_v ;
  assign pcie_ep_fc_sel = 3'd0 ;
  assign pcie_ep_m_axis_rx_tready = x1__h4489 ;
  assign pcie_ep_pci_exp_rxn = pcie_rxn_v ;
  assign pcie_ep_pci_exp_rxp = pcie_rxp_v ;
  assign pcie_ep_pipe_mmcm_lock_in = clockGen_pll_LOCKED ;
  assign pcie_ep_rx_np_ok = 1'd1 ;
  assign pcie_ep_rx_np_req = 1'd1 ;
  assign pcie_ep_s_axis_tx_tdata =
	     WILL_FIRE_RL_fAxiTx_rule_deq ?
	       MUX_pcie_ep_s_axis_tx_tdata_1__VAL_1 :
	       64'd0 ;
  assign pcie_ep_s_axis_tx_tkeep =
	     WILL_FIRE_RL_fAxiTx_rule_deq ?
	       MUX_pcie_ep_s_axis_tx_tkeep_1__VAL_1 :
	       8'd0 ;
  assign pcie_ep_s_axis_tx_tlast =
	     WILL_FIRE_RL_fAxiTx_rule_deq &&
	     MUX_pcie_ep_s_axis_tx_tlast_1__VAL_1 ;
  assign pcie_ep_s_axis_tx_tuser = 4'b0 ;
  assign pcie_ep_s_axis_tx_tvalid = !WILL_FIRE_RL_drive_axi_tx2 ;
  assign pcie_ep_tx_cfg_gnt = 1'd1 ;

  // remaining internal signals
  assign IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d80 =
	     fAxiRx_rw_enq_whas ?
	       fAxiRx_rw_enq_wget[94:73] :
	       fAxiRx_taggedReg[94:73] ;
  assign IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d90 =
	     fAxiRx_rw_enq_whas ?
	       fAxiRx_rw_enq_wget[71:64] :
	       fAxiRx_taggedReg[71:64] ;
  assign IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d97 =
	     fAxiRx_rw_enq_whas ?
	       fAxiRx_rw_enq_wget[63:0] :
	       fAxiRx_taggedReg[63:0] ;
  assign v_data__h7565 =
	     { gb_tlp_request_get[31:0], gb_tlp_request_get[63:32] } ;
  assign v_keep__h7564 =
	     { gb_tlp_request_get[67:64], gb_tlp_request_get[71:68] } ;
  assign x1__h4489 = !fAxiRx_taggedReg[95] ;
  assign y_avValue_be__h8644 =
	     { IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d90[3:0],
	       IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d90[7:4] } ;
  assign y_avValue_data__h8645 =
	     { IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d97[31:0],
	       IF_fAxiRx_rw_enq_whas__1_THEN_fAxiRx_rw_enq_wg_ETC___d97[63:32] } ;

  // handling of inlined registers

  always@(posedge bbufc_O)
  begin
    if (rsto_OUT_RST == `BSV_RESET_VALUE)
      begin
        pclk_sel <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pclk_sel_reg1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	pclk_sel_reg2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (pclk_sel_EN) pclk_sel <= `BSV_ASSIGNMENT_DELAY pclk_sel_D_IN;
	if (pclk_sel_reg1_EN)
	  pclk_sel_reg1 <= `BSV_ASSIGNMENT_DELAY pclk_sel_reg1_D_IN;
	if (pclk_sel_reg2_EN)
	  pclk_sel_reg2 <= `BSV_ASSIGNMENT_DELAY pclk_sel_reg2_D_IN;
      end
  end

  always@(posedge pcie_ep_user_clk_out)
  begin
    if (!`BSV_RESET_VALUE == `BSV_RESET_VALUE)
      begin
        fAxiRx_taggedReg <= `BSV_ASSIGNMENT_DELAY
	    96'h2AAAAAAAAAAAAAAAAAAAAAAA;
	fAxiTx_taggedReg <= `BSV_ASSIGNMENT_DELAY 74'h0AAAAAAAAAAAAAAAAAA;
      end
    else
      begin
        if (fAxiRx_taggedReg_EN)
	  fAxiRx_taggedReg <= `BSV_ASSIGNMENT_DELAY fAxiRx_taggedReg_D_IN;
	if (fAxiTx_taggedReg_EN)
	  fAxiTx_taggedReg <= `BSV_ASSIGNMENT_DELAY fAxiTx_taggedReg_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fAxiRx_taggedReg = 96'hAAAAAAAAAAAAAAAAAAAAAAAA;
    fAxiTx_taggedReg = 74'h2AAAAAAAAAAAAAAAAAA;
    pclk_sel = 1'h0;
    pclk_sel_reg1 = 8'hAA;
    pclk_sel_reg2 = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkPcieEndpointX7

